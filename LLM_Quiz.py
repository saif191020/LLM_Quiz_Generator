import streamlit as st
import google.generativeai as genai
from utilities.utility import extract_json
from addtional_data import emojis, quirky_responses
from random import shuffle, choice
import logging
import time
import math


# Configure the logger
logging.basicConfig(
    filename="app.log",  # Name of the log file
    level=logging.DEBUG,  # Set the logging level
    format="%(asctime)s %(levelname)-8s %(message)s",  # Log format
    datefmt='%Y-%m-%d %H:%M'
)
# Create a logger object
logger = logging.getLogger(__name__)

def reset_app():
    for key in st.session_state.keys():
        if key == 'gemini-api-key':
            continue
        del st.session_state[key]

@st.dialog("Cast your vote")
def call_dialog(data):
    st.write("An Error Occured maybe api key wrong or issues with prompt:")
    st.write("Use the following to debug")
    st.error(data, icon="ðŸš¨")
    btn = st.button('Reset')
    if btn:
        if 'gemini-api-key' in st.session_state:
            del st.session_state['gemini-api-key']
        reset_app()
        st.rerun()
    

if 'sidebar_state' in st.session_state and 'app_status' in st.session_state and st.session_state.app_status=='start':
    st.set_page_config(initial_sidebar_state = st.session_state.sidebar_state)
    st.session_state.sidebar_state = 'auto'


with st.sidebar:
    api_key = st.text_input('Gemini API Key', key='gemini-api-key', type='password', placeholder='API Key')
    "[Get an Gemini API Key](https://ai.google.dev/gemini-api/docs/api-key)"

# st.session_state


def reset():
    st.session_state.page = 'llm_quiz'
    st.session_state.app_status = 'start'
    st.session_state.points = 0
    st.session_state.prompt = ''
    st.session_state.model = None
    st.session_state.current_qno = 0
    st.session_state.num_of_q = 0
    st.session_state.quiz_status =False
    st.session_state.next_question = False

def validate_response(json_data)->bool:
    if json_data is None and json_data or len(json_data)<=0:
        return False
    if len(json_data) < st.session_state.num_of_q:
        logger.error(f'Not enough questions :Expected {st.session_state.num_of_q} :Actual {len(json_data)}')
        return False
    for data in json_data:
        if not all(key in data for key in ['question', 'a','b','c','d','answer','explanation']):        
            logger.error('Invalid Keys Actual')
            return False
        if data['answer'] not in ['a','b','c','d']:
            logger.error('Invalid Answer')
            return False

    return True 

def submit_quiz_answer(quiz):
    print(st.session_state.selected_answer_choice,st.session_state.quiz_status )
    if st.session_state.selected_answer_choice and not st.session_state.quiz_status:
        if quiz[quiz['answer']] == st.session_state.selected_answer_choice:
            st.session_state.points = st.session_state.points+1 
        st.session_state.quiz_status =True

if 'page' in st.session_state and st.session_state.page != 'llm_quiz':
    reset()

if 'app_status' not in st.session_state:
    reset() 

def setup_gemini():
    if 'model' in  st.session_state and st.session_state.model:
        return
    if 'gemini-api-key' in st.session_state:
        genai.configure(api_key=st.session_state['gemini-api-key'])
        model = genai.GenerativeModel('gemini-1.5-flash', system_instruction=f'''
            You are an intelligent system designed to generate high-quality, multiple-choice quiz questions on various topics. Follow these instructions carefully:

            You will be provided with the topic for the question as prompt 
            you should reply only as JSON with keys as 'question', 'a','b','c','d','answer','explanation' 
                              return as array with {st.session_state.num_of_q} question and answer 
            answer should contain with alphabet contains the correct answer and only one option should be correct. 
            DO NOT Repeate the same question again for a give topic 
            ''', generation_config=genai.types.GenerationConfig(temperature=1))
        st.session_state.model = model
        
    else : st.session_state.app_status = 'start'

def get_question():
    model = st.session_state.model
    response = model.generate_content('Topic: '+st.session_state.prompt)
    count =0
    valid = False
    json= {}
    while count <3:
        json = extract_json(response.text)
        if validate_response(json):
            valid = True
            break
        logger.info(response.text)
        time.sleep(0.5)
        count = count+1 
    
    print('Running LLM API')
    if not valid:
        return response, valid
    
    return json, valid

def start_view():
    st.write("This quiz is generated by a language model (LLM) and may contain inaccuracies, so please don't take the results at face value. Enter your **_API Key_** in the sidebar and click 'Agree and Continue' to proceed.")
    clicked = st.button('Agree and Continue')
    if clicked:
        if not st.session_state['gemini-api-key']:
            st.warning('Please Enter API Key in the Sidebar')
            st.session_state.sidebar_state = 'expanded'
        else:
            st.session_state.app_status='prompt'
            st.rerun()

def prompt_view():
    prompt=st.text_input('What do you want the quiz to be about?',placeholder="eg.:The One Piece (Anime), Aws Developer Certification, Snowflake Snow Pro Core Certification")
    num_of_q = int(st.number_input('Number Of Questions',min_value=1, max_value=15, step=1))
    clicked = st.button('Continue')
    if clicked:
        if prompt and num_of_q:
            st.session_state.prompt = prompt
            st.session_state.num_of_q = num_of_q
            with st.spinner('Generating Your Quiz!'):
                setup_gemini()
                data, valid = get_question()
            
            if valid:
                st.session_state.quiz_data = data
                st.session_state.app_status='quiz'
                st.rerun()
            else: 
                call_dialog(data)
        else:
            st.error('Please Enter All Values')

def quiz_view():
    qno =st.session_state.current_qno
    if qno >= len(st.session_state.quiz_data):
        st.session_state.app_status = 'end'
        st.rerun()

    quiz = st.session_state.quiz_data[qno]
    with st.form('LLM_QUIZ'+str(qno)):
        st.caption(f"Question : {qno+1}", help=f"Question {qno+1} of {len(st.session_state.quiz_data)}")
        selected_option = st.radio(
            quiz['question'], 
            options=[quiz['a'], quiz['b'], quiz['c'], quiz['d']], 
            index=None, key='selected_answer_choice', disabled=st.session_state.quiz_status)
        form_submitted = st.form_submit_button(use_container_width = True, on_click=submit_quiz_answer, args=([quiz] ))
    if form_submitted:
        if not selected_option:
            st.warning('Please select an option')
        else:
            st.button('Next Question',key='next_question')

            if selected_option == quiz[quiz['answer']]:
                st.success("Correct!")
            else:
                st.error(f"Wrong! The correct option is Option {quiz['answer']}")
            
            with st.expander('Explanation',icon='ðŸ“–', expanded=True):
                    st.write(quiz['explanation'])
    
    if 'next_question' in st.session_state and st.session_state.next_question: 
        st.session_state.current_qno = st.session_state.current_qno+1
        st.session_state.quiz_status = False
        st.rerun()
def end_view():
    st.title('Quiz Completed! :balloon:')
    st.balloons()
    correct, total = st.session_state.points,st.session_state.current_qno
    ind = max(math.ceil((correct/total)*10)-1,0)
    st.header(f'You Scored :blue[{correct}/{total}] {emojis[ind]}')
    st.caption(choice(quirky_responses[ind]))
    st.button('Reset',on_click=reset_app)


def main():

    c1, c2 = st.columns([2,1])
    c1.title('LLM Quiz', anchor=False)
    if st.session_state.app_status not in  ['start', 'prompt']:
        c2.title(f':red[_Score_] : :blue[{str(st.session_state.points)}]', anchor=False)
    
    if st.session_state.app_status == 'start':
        start_view()
        
    if st.session_state.app_status == 'prompt':
        st.session_state.current_qno=0
        prompt_view()
    
    if st.session_state.app_status == 'quiz':
        quiz_view()

    if st.session_state.app_status == 'end':
        end_view()

if __name__ == '__main__': 
    try:
        main()
    except Exception as err:
        st.exception(err)

